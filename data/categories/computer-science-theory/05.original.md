```yaml
- text: "I tried to prove P=NP, but my proof had O(n!) complexity."
  explanation: "This joke plays on the irony that attempting to solve the famous P vs NP problem (which asks if problems whose solutions can be verified quickly can also be solved quickly) resulted in a factorial time complexity - one of the worst possible complexities, demonstrating the opposite of efficiency."

- text: "Why did the Turing machine go to therapy? It couldn't decide if it would halt."
  explanation: "This references the famous Halting Problem, which states that no algorithm can determine whether an arbitrary program will halt or run forever. The joke anthropomorphizes the machine's undecidability as an anxiety disorder."

- text: "My algorithm is so efficient, it solves problems before they exist. Unfortunately, that's NP-hard to prove."
  explanation: "This uses absurdist humor combined with the technical concept of NP-hard problems (problems for which no polynomial-time solution is known), creating an impossible scenario that mirrors the difficulty of proving computational complexity."

- text: "A quantum computer walks into a bar. And doesn't. The bartender is uncertain."
  explanation: "This plays on quantum superposition (being in multiple states simultaneously) and Heisenberg's uncertainty principle, applying quantum mechanics concepts to a classic joke setup."

- text: "I wrote a recursive function to understand recursion. Now I'm stuck in an infinite loop of enlightenment."
  explanation: "This self-referential joke mirrors the structure of recursion itself, where understanding recursion requires understanding recursion, creating a humorous paradox about learning the concept."

- text: "Why do computer scientists confuse Halloween and Christmas? Because Oct 31 equals Dec 25."
  explanation: "This is a classic programmer joke playing on number systems: October 31 in octal (base-8) equals 25 in decimal (31₈ = 3×8 + 1 = 25₁₀), and December 25 is already in decimal, making them numerically equivalent in different bases."

- text: "I optimized my sorting algorithm to O(1). It just returns the array and says it's sorted."
  explanation: "This joke satirizes the obsession with algorithmic efficiency by presenting a 'solution' that achieves perfect constant time complexity by simply lying about doing the work - technically fast but completely useless."

- text: "A computer scientist's pickup line: 'Are you an NP-complete problem? Because I'd spend exponential time trying to solve you.'"
  explanation: "This combines romantic humor with complexity theory, referencing NP-complete problems that may require exponential time to solve, turning computational intractability into a compliment about dedication."

- text: "My thesis proved that all algorithms are O(1) if you ignore the input size. The committee was not impressed."
  explanation: "This satirizes academic rigor by presenting a technically true but completely meaningless statement - any algorithm is constant time if you don't consider the variable that matters most, exposing the absurdity through formal correctness."

- text: "Why did the graph theorist break up with the topologist? Too many cycles, not enough closure."
  explanation: "This uses mathematical double meanings: 'cycles' refers to circular paths in graphs and relationship patterns, while 'closure' means both emotional resolution and a topological property, creating layered meaning."

- text: "I invented a new data structure with O(1) insertion, deletion, and search. It's called 'doing nothing.'"
  explanation: "This extends the earlier optimization joke by creating a 'perfect' data structure that achieves optimal complexity for all operations by simply not performing them, satirizing the gap between theoretical perfection and practical utility."

- text: "A finite automaton walks into a bar, sees another finite automaton, and says 'I recognize you!' The other replies, 'That's irregular.'"
  explanation: "This plays on formal language theory: finite automata recognize regular languages, and 'irregular' works both as a social response meaning 'unusual' and as a technical term for non-regular languages that finite automata cannot recognize."

- text: "My computer science professor said, 'There are two hard problems in computer science: cache invalidation, naming things, and off-by-one errors.'"
  explanation: "This is a classic meta-joke that demonstrates an off-by-one error (listing three things when claiming two) while listing problems that include off-by-one errors, making the joke self-demonstrating and recursive in its humor."

- text: "I proved my algorithm correct by induction. Base case: it works for n=0. Inductive step: I assume it works."
  explanation: "This satirizes mathematical proof by induction by skipping the crucial inductive step (proving that if it works for n, it works for n+1), showing a 'proof' that proves nothing while following the formal structure."

- text: "Why don't lambda calculus expressions ever feel lonely? They're always looking for something to reduce with."
  explanation: "This anthropomorphizes lambda calculus (the theoretical foundation of functional programming) where expressions are 'reduced' by applying functions to arguments, turning the mechanical process into a search for companionship."

- text: "A programmer's wife asks, 'Could you go to the store and get a liter of milk? If they have eggs, get a dozen.' He returns with 12 liters of milk. She asks why. He says, 'They had eggs.'"
  explanation: "This demonstrates the difference between natural language and programming logic: a human interprets 'if they have eggs, get a dozen [eggs]' but a programmer interprets it as 'if (eggs exist) then quantity = 12 [of milk]', showcasing conditional logic misinterpretation."

- text: "I created a new complexity class: O(maybe). It's either polynomial or exponential, depending on whether I debug before the deadline."
  explanation: "This satirizes both complexity theory and software development reality by creating a fake complexity class based on practical constraints rather than mathematical properties, acknowledging that real-world performance often depends on non-algorithmic factors."

- text: "Two strings walk into a bar. The bartender says, 'What'll it be?' One string says, 'I'll have a beer.' The other says, 'I'll have a beer too. No wait, make that a b33r... no, a b34r...' The first string apologizes: 'Sorry, my friend isn't null-terminated.'"
  explanation: "This joke requires understanding of C-style strings that end with a null character - without proper termination, reading a string continues into adjacent memory, producing garbage characters, which is portrayed as the string being unable to finish its order."

- text: "Why did the complexity theorist refuse to date? Because finding the optimal match is NP-hard, and they weren't willing to settle for an approximation algorithm."
  explanation: "This applies computational complexity to romance: finding an optimal solution to NP-hard problems requires potentially exponential time, so practical approaches use approximation algorithms that find 'good enough' solutions - a metaphor for settling in relationships."

- text: "A Boolean walks into a bar. The bartender asks, 'What'll you have?' The Boolean says, 'True.' The bartender serves everything. The Boolean says, 'False,' and the bartender takes it all away. The Boolean says, 'NULL,' and the bartender has an existential crisis."
  explanation: "This escalates through logical values: True might mean 'yes to everything,' False means 'no to everything,' but NULL (neither true nor false, representing unknown or undefined) breaks the binary system entirely, causing philosophical confusion that mirrors the programming challenges of null handling."

- text: "I told my professor I'd solve the Halting Problem. He said, 'Let me know when you're done.' I said, 'That's the problem - I can't tell if I'll ever finish.'"
  explanation: "This is peak meta-humor: the Halting Problem proves you can't determine if an arbitrary program will finish, and the student's attempt to solve it becomes self-referential - they can't know if their solution attempt will halt, which IS the problem they're trying to solve, creating a perfect recursive paradox."
```